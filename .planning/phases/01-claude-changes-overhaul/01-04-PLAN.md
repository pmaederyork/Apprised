---
phase: 01-claude-changes-overhaul
plan: 04
type: execute
wave: 3
depends_on: [01-01, 01-02]
files_modified:
  - backend/static/js/claude-changes.js
  - backend/static/js/documents.js
autonomous: true

must_haves:
  truths:
    - "Pattern operations find ALL matching elements client-side"
    - "'Remove all empty paragraphs' removes ALL empty paragraphs, not just Claude-identified ones"
    - "Pattern matches shown as grouped change with count"
    - "All matching elements highlighted before accepting"
  artifacts:
    - path: "backend/static/js/claude-changes.js"
      provides: "Pattern matching system"
      contains: "PatternMatcher"
    - path: "backend/static/js/documents.js"
      provides: "Pattern change parsing"
      contains: "delete-pattern"
  key_links:
    - from: "backend/static/js/documents.js:parseClaudeEditResponse"
      to: "backend/static/js/claude-changes.js:PatternMatcher"
      via: "Pattern change type handling"
      pattern: "PatternMatcher\\.findMatches"
---

<objective>
Implement client-side pattern matching for bulk operations like "remove all empty lines."

Purpose: Enable comprehensive bulk operations where the client finds ALL matching elements, not relying on Claude to enumerate each one. This ensures "remove all empty paragraphs" actually removes ALL of them.

Output: PatternMatcher system integrated into change parsing and preview.
</objective>

<execution_context>
@/Users/pax/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pax/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-claude-changes-overhaul/01-CONTEXT.md
@.planning/phases/01-claude-changes-overhaul/01-RESEARCH.md
@.planning/phases/01-claude-changes-overhaul/01-01-SUMMARY.md
@.planning/phases/01-claude-changes-overhaul/01-02-SUMMARY.md
@backend/static/js/claude-changes.js
@backend/static/js/documents.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PatternMatcher to ClaudeChanges</name>
  <files>backend/static/js/claude-changes.js</files>
  <action>
Add a PatternMatcher object inside the ClaudeChanges module (at the top of the file, after the initial property declarations). This keeps pattern matching functionality co-located with change management:

```javascript
/**
 * Pattern Matcher for bulk operations
 * Finds all elements matching predefined patterns in the document
 */
PatternMatcher: {
    patterns: {
        'empty-paragraphs': {
            description: 'Paragraphs with no content or only whitespace',
            selector: 'p',
            validator: (el) => {
                const text = el.textContent.trim();
                // Empty text AND no meaningful child elements (images, etc.)
                return text === '' && !el.querySelector('img, br, hr, iframe, video, audio');
            }
        },

        'empty-lines': {
            description: 'Any block element with no content',
            selector: 'p, div, h1, h2, h3, h4, h5, h6',
            validator: (el) => {
                const text = el.textContent.trim();
                return text === '' && el.children.length === 0;
            }
        },

        'duplicate-breaks': {
            description: 'Consecutive BR tags',
            selector: 'br + br',
            validator: () => true  // Selector handles adjacency
        },

        'trailing-whitespace': {
            description: 'Elements ending with excessive whitespace',
            selector: 'p, div, li, h1, h2, h3, h4, h5, h6',
            validator: (el) => {
                const html = el.innerHTML;
                // Check for multiple trailing &nbsp; or spaces before closing
                return /(&nbsp;|\s){3,}$/.test(html);
            }
        }
    },

    /**
     * Register a custom pattern
     * @param {string} name - Pattern identifier
     * @param {Object} config - { description, selector, validator }
     */
    register(name, config) {
        this.patterns[name] = config;
    },

    /**
     * Find all elements matching a pattern
     * @param {Element} container - Container to search within
     * @param {string} patternName - Name of pattern to match
     * @returns {Element[]} Array of matching elements
     */
    findMatches(container, patternName) {
        const pattern = this.patterns[patternName];
        if (!pattern) {
            console.warn(`Unknown pattern: ${patternName}`);
            return [];
        }

        const candidates = container.querySelectorAll(pattern.selector);

        // Apply validator to filter false positives
        if (pattern.validator) {
            return Array.from(candidates).filter(pattern.validator);
        }

        return Array.from(candidates);
    },

    /**
     * Create individual changes from pattern matches
     * @param {Element} container - Container with elements
     * @param {string} patternName - Pattern that was matched
     * @param {string} operation - 'delete' or 'modify'
     * @returns {Array} Array of change objects
     */
    createChangesFromPattern(container, patternName, operation = 'delete') {
        const matches = this.findMatches(container, patternName);

        return matches.map(el => ({
            id: Storage.generateChangeId(),
            type: operation,
            targetId: el.dataset.editId || null,
            originalContent: el.outerHTML,
            _patternSource: patternName,
            status: 'pending'
        }));
    },

    /**
     * Get pattern description for UI display
     * @param {string} patternName - Pattern name
     * @returns {string} Human-readable description
     */
    getDescription(patternName) {
        const pattern = this.patterns[patternName];
        return pattern ? pattern.description : patternName;
    }
},
```

Key design decisions:
- Patterns defined with CSS selector + validator function for accuracy
- validator prevents false positives (CSS :empty has edge cases)
- Each pattern creates individual changes with targetId when available
- Extensible via register() method for custom patterns
  </action>
  <verify>
1. ClaudeChanges.PatternMatcher object exists
2. PatternMatcher.patterns contains at least: empty-paragraphs, empty-lines, duplicate-breaks
3. PatternMatcher.findMatches and createChangesFromPattern methods exist
  </verify>
  <done>
PatternMatcher system added with predefined patterns for empty paragraphs, empty lines, and duplicate breaks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update parseClaudeEditResponse() for pattern changes</name>
  <files>backend/static/js/documents.js</files>
  <action>
Modify `parseClaudeEditResponse()` in documents.js (around line 2142) to detect and expand pattern-based changes:

Find the existing parsing logic and add pattern change handling:

```javascript
parseClaudeEditResponse(responseText) {
    if (!responseText) return null;

    // Look for <document_edit> tags in Claude's response
    const editMatch = responseText.match(/<document_edit>(.*?)<\/document_edit>/s);

    if (!editMatch) {
        return null;
    }

    const editXML = editMatch[1];
    const changes = [];

    // Parse each <change> element
    const changeRegex = /<change\s+((?:[^>"]|"[^"]*")*?)>(.*?)<\/change>/gs;
    let match;

    while ((match = changeRegex.exec(editXML)) !== null) {
        const [, attributeString, content] = match;

        const type = attributeString.match(/type="([^"]+)"/)?.[1];

        // Check for pattern-based changes (e.g., type="delete-pattern")
        if (type && type.endsWith('-pattern')) {
            const patternMatch = attributeString.match(/pattern="([^"]+)"/);
            const patternName = patternMatch ? patternMatch[1] : null;

            if (patternName && typeof ClaudeChanges !== 'undefined' && ClaudeChanges.PatternMatcher) {
                // Get the editor root to find matches
                const editorRoot = this.squireEditor?.getRoot();
                if (editorRoot) {
                    // Determine operation from type (delete-pattern -> delete)
                    const operation = type.replace('-pattern', '');

                    // Create individual changes for each match
                    const patternChanges = ClaudeChanges.PatternMatcher.createChangesFromPattern(
                        editorRoot,
                        patternName,
                        operation
                    );

                    // Add pattern source info for UI grouping
                    patternChanges.forEach(change => {
                        change._patternGroup = {
                            name: patternName,
                            description: ClaudeChanges.PatternMatcher.getDescription(patternName),
                            totalCount: patternChanges.length
                        };
                    });

                    changes.push(...patternChanges);
                    console.log(`Pattern "${patternName}": Found ${patternChanges.length} matches`);
                }
            }
            continue; // Skip normal parsing for pattern changes
        }

        // Normal change parsing (existing code)
        const insertAfterMatch = attributeString.match(/insertAfter="(.*?)"(?=\s|>|$)/s);
        const insertBeforeMatch = attributeString.match(/insertBefore="(.*?)"(?=\s|>|$)/s);

        const insertAfter = insertAfterMatch ? insertAfterMatch[1] : undefined;
        const insertBefore = insertBeforeMatch ? insertBeforeMatch[1] : undefined;

        const originalMatch = content.match(/<original>(.*?)<\/original>/s);
        const newMatch = content.match(/<new>(.*?)<\/new>/s);

        const change = {
            id: Storage.generateChangeId(),
            type: type,
            insertAfter: insertAfter || undefined,
            insertBefore: insertBefore || undefined,
            originalContent: originalMatch ? originalMatch[1].trim() : null,
            newContent: newMatch ? newMatch[1].trim() : null,
            status: 'pending'
        };

        changes.push(change);
    }

    return changes.length > 0 ? changes : null;
},
```

Key changes:
- Detects `type="delete-pattern"` or similar pattern types
- Extracts `pattern="pattern-name"` attribute
- Uses PatternMatcher to find ALL matches client-side
- Creates individual changes with _patternGroup metadata for UI grouping
- Falls through to normal parsing for non-pattern changes
  </action>
  <verify>
1. parseClaudeEditResponse() checks for type ending in "-pattern"
2. Pattern changes call ClaudeChanges.PatternMatcher.createChangesFromPattern
3. Pattern changes have _patternGroup metadata attached
4. Console logs pattern match count
  </verify>
  <done>
parseClaudeEditResponse() expands pattern changes into individual matched changes with grouping metadata.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add pattern highlighting to renderChangesInDocument()</name>
  <files>backend/static/js/documents.js</files>
  <action>
Modify `renderChangesInDocument()` to highlight all pattern matches together. Update the change number indicator to show pattern grouping:

In renderChangesInDocument() (around line 2000-2005), update the change number indicator section:

```javascript
// Add change number indicator with pattern grouping info
const numberIndicator = document.createElement('span');
numberIndicator.className = 'claude-change-number';

// Check if this is part of a pattern group
if (change._patternGroup) {
    // Show pattern info on first element of group
    const isFirst = !changes.slice(0, index).some(c =>
        c._patternGroup?.name === change._patternGroup.name
    );

    if (isFirst) {
        numberIndicator.textContent = `${change._patternGroup.totalCount}x`;
        numberIndicator.title = `Pattern: ${change._patternGroup.description}`;
        numberIndicator.classList.add('pattern-group-indicator');
    } else {
        numberIndicator.textContent = (index + 1).toString();
        numberIndicator.classList.add('pattern-member');
    }
} else {
    numberIndicator.textContent = (index + 1).toString();
}

changeElement.appendChild(numberIndicator);
```

Also add CSS class for pattern highlighting. Add this to the CSS in the document or as inline style application:

```javascript
// At the top of renderChangesInDocument(), add pattern styling if not already in CSS
if (!document.getElementById('pattern-matcher-styles')) {
    const style = document.createElement('style');
    style.id = 'pattern-matcher-styles';
    style.textContent = `
        .pattern-group-indicator {
            background: #7c3aed !important;
            font-weight: bold;
        }
        .pattern-member {
            opacity: 0.7;
        }
        .claude-change-delete[data-pattern-source] {
            border-left: 3px solid #7c3aed;
        }
    `;
    document.head.appendChild(style);
}
```

And update the changeElement creation to include pattern source:

```javascript
if (change._patternSource) {
    changeElement.setAttribute('data-pattern-source', change._patternSource);
}
```

This provides visual feedback that:
- Pattern matches are grouped (first shows "12x")
- All matches are highlighted together
- Purple accent distinguishes pattern operations from regular changes
  </action>
  <verify>
1. Pattern changes show "Nx" indicator on first element of group
2. Pattern changes have data-pattern-source attribute
3. CSS styles for pattern-group-indicator exist
4. All pattern matches are visually highlighted in document
  </verify>
  <done>
Pattern matches are visually grouped and highlighted to show all affected elements before accepting.
  </done>
</task>

</tasks>

<verification>
1. Create document with multiple empty paragraphs (type some text, add blank lines)
2. Ask Claude: "Remove all empty paragraphs"
3. Claude should respond with `<change type="delete-pattern" pattern="empty-paragraphs">`
4. System should find ALL empty paragraphs (not just ones Claude might have listed)
5. All empty paragraphs should be highlighted with purple accent
6. First match should show count indicator (e.g., "5x")
7. Accept All should remove ALL empty paragraphs in single operation
</verification>

<success_criteria>
- Pattern operations find ALL matching elements, not just Claude-enumerated ones
- Pattern matches displayed with grouping indicator and count
- Accept All on pattern removes all matches
- Pattern system is extensible (register() method works)
- Backward compatible with non-pattern changes
</success_criteria>

<output>
After completion, create `.planning/phases/01-claude-changes-overhaul/01-04-SUMMARY.md`
</output>
