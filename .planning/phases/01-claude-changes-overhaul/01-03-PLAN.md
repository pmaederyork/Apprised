---
phase: 01-claude-changes-overhaul
plan: 03
type: execute
wave: 2
depends_on: [01-01, 01-02]
files_modified:
  - backend/static/js/claude-changes.js
autonomous: true

must_haves:
  truths:
    - "Accept All applies all changes with single DOM rebuild"
    - "Accepting 10+ changes feels instant (no perceptible delay)"
    - "Per-change undo still works after batch accept"
  artifacts:
    - path: "backend/static/js/claude-changes.js"
      provides: "Batch apply functionality"
      contains: "batchApplyChanges"
  key_links:
    - from: "backend/static/js/claude-changes.js:acceptAll"
      to: "backend/static/js/claude-changes.js:batchApplyChanges"
      via: "Direct call"
      pattern: "batchApplyChanges"
---

<objective>
Implement batch DOM operations for "Accept All" with single reflow.

Purpose: Make accepting many changes instant by applying all changes to an off-DOM container and updating the editor once, rather than N reflows for N changes.

Output: Updated acceptAll() method using DocumentFragment batch processing.
</objective>

<execution_context>
@/Users/pax/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pax/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-claude-changes-overhaul/01-CONTEXT.md
@.planning/phases/01-claude-changes-overhaul/01-RESEARCH.md
@.planning/phases/01-claude-changes-overhaul/01-01-SUMMARY.md
@backend/static/js/claude-changes.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add batchApplyChanges() method</name>
  <files>backend/static/js/claude-changes.js</files>
  <action>
Add a new `batchApplyChanges()` method to ClaudeChanges that applies all changes to an off-DOM container and returns the final HTML. Add this after the reconstructDocument() method:

```javascript
/**
 * Batch apply changes with single DOM update
 * Uses DocumentFragment for optimal performance
 * @param {string} originalHTML - The original clean document HTML
 * @param {Array} changesToApply - Changes to apply (will be marked as accepted)
 * @returns {string} The resulting HTML after all changes applied
 */
batchApplyChanges(originalHTML, changesToApply) {
    console.log(`Batch applying ${changesToApply.length} change(s)`);
    const startTime = performance.now();

    // Mark all changes as accepted first
    changesToApply.forEach(change => {
        change.status = 'accepted';
    });

    // Get all accepted changes (including previously accepted + newly accepted)
    const allAccepted = this.changes.filter(c => c.status === 'accepted');

    // Use reconstructDocument with all accepted changes
    const resultHTML = this.reconstructDocument(this.originalDocumentHTML, allAccepted, {
        skipOnFailure: true
    });

    const elapsed = performance.now() - startTime;
    console.log(`Batch apply completed in ${elapsed.toFixed(2)}ms`);

    return resultHTML;
},
```

This method:
- Marks all provided changes as accepted
- Gets the full set of accepted changes
- Uses reconstructDocument() which already handles off-DOM operations
- Logs performance timing for verification
  </action>
  <verify>
batchApplyChanges method exists in claude-changes.js and includes performance.now() timing.
  </verify>
  <done>
batchApplyChanges() method added for efficient batch change application.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite acceptAll() to use batch processing</name>
  <files>backend/static/js/claude-changes.js</files>
  <action>
Replace the existing `acceptAll()` method (around line 604) with a new implementation that uses batch processing instead of calling acceptChange() in a loop:

```javascript
/**
 * Accept all pending changes with single DOM update
 * Optimized for batch operations - single reflow regardless of change count
 */
acceptAll() {
    if (!this.isInReviewMode()) return;

    const pendingChanges = this.changes.filter(c => c.status === 'pending');
    if (pendingChanges.length === 0) {
        this.exitReviewMode();
        return;
    }

    // Capture state BEFORE applying changes (for undo)
    this.captureHistoryState();

    console.log(`Accept All: Processing ${pendingChanges.length} pending change(s)`);

    // Batch apply all pending changes
    const resultHTML = this.batchApplyChanges(this.originalDocumentHTML, pendingChanges);

    // Single DOM update
    if (Documents.squireEditor) {
        Documents.squireEditor.saveUndoState();
        const editor = Documents.squireEditor.getRoot();
        if (editor) {
            // Use DocumentFragment for single reflow
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = resultHTML;

            const fragment = document.createDocumentFragment();
            while (tempDiv.firstChild) {
                fragment.appendChild(tempDiv.firstChild);
            }

            // Clear and replace in one operation
            editor.innerHTML = '';
            editor.appendChild(fragment);
        }
    }

    // Ensure new elements get IDs
    if (typeof ElementIds !== 'undefined' && Documents.squireEditor) {
        ElementIds.ensureIds(Documents.squireEditor.getRoot());
    }

    // Clean up change numbers
    this.cleanupChangeNumbers();

    // Save changes to storage
    Storage.saveClaudeChanges(this.documentId, {
        changeId: 'changes_' + Date.now(),
        documentId: this.documentId,
        timestamp: Date.now(),
        changes: this.changes
    });

    // Capture state AFTER applying changes (creates undo point)
    setTimeout(() => {
        this.captureHistoryState();
        if (Documents && Documents.updateUndoRedoButtons) {
            Documents.updateUndoRedoButtons();
        }
    }, 100);

    // Exit review mode
    this.exitReviewMode();
},
```

Key differences from previous implementation:
- Does NOT call acceptChange() in a loop (which caused N reflows)
- Uses batchApplyChanges() for a single reconstruction
- Uses DocumentFragment for the final DOM update (single reflow)
- Ensures new elements get IDs after batch operation
- Same undo/redo state management for consistency
  </action>
  <verify>
1. acceptAll() method no longer contains a forEach loop calling acceptChange()
2. acceptAll() calls batchApplyChanges() instead
3. acceptAll() uses DocumentFragment for the final DOM update
4. acceptAll() calls ElementIds.ensureIds() after update
  </verify>
  <done>
acceptAll() uses batch processing with single DOM reflow for instant operation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Optimize rejectAll() similarly</name>
  <files>backend/static/js/claude-changes.js</files>
  <action>
Update `rejectAll()` method (around line 618) to use batch processing for consistency. While reject is simpler (just marking as rejected), we should still optimize the DOM update:

```javascript
/**
 * Reject all pending changes with single DOM update
 */
rejectAll() {
    if (!this.isInReviewMode()) return;

    const pendingChanges = this.changes.filter(c => c.status === 'pending');
    if (pendingChanges.length === 0) {
        this.exitReviewMode();
        return;
    }

    // Capture state BEFORE rejecting (for undo)
    this.captureHistoryState();

    console.log(`Reject All: Processing ${pendingChanges.length} pending change(s)`);

    // Mark all as rejected (batch)
    pendingChanges.forEach(change => {
        change.status = 'rejected';
    });

    // Reconstruct document with only accepted changes (rejected are excluded)
    const acceptedChanges = this.changes.filter(c => c.status === 'accepted');
    const resultHTML = this.reconstructDocument(this.originalDocumentHTML, acceptedChanges, {
        skipOnFailure: true
    });

    // Single DOM update
    if (Documents.squireEditor) {
        Documents.squireEditor.saveUndoState();
        const editor = Documents.squireEditor.getRoot();
        if (editor) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = resultHTML;

            const fragment = document.createDocumentFragment();
            while (tempDiv.firstChild) {
                fragment.appendChild(tempDiv.firstChild);
            }

            editor.innerHTML = '';
            editor.appendChild(fragment);
        }
    }

    // Ensure elements have IDs
    if (typeof ElementIds !== 'undefined' && Documents.squireEditor) {
        ElementIds.ensureIds(Documents.squireEditor.getRoot());
    }

    // Clean up
    this.cleanupChangeNumbers();

    // Save to storage
    Storage.saveClaudeChanges(this.documentId, {
        changeId: 'changes_' + Date.now(),
        documentId: this.documentId,
        timestamp: Date.now(),
        changes: this.changes
    });

    // Capture undo point
    setTimeout(() => {
        this.captureHistoryState();
        if (Documents && Documents.updateUndoRedoButtons) {
            Documents.updateUndoRedoButtons();
        }
    }, 100);

    this.exitReviewMode();
},
```

This mirrors the acceptAll() pattern for consistency.
  </action>
  <verify>
1. rejectAll() no longer calls rejectChange() in a loop
2. rejectAll() uses DocumentFragment for DOM update
3. rejectAll() calls ElementIds.ensureIds() after update
  </verify>
  <done>
rejectAll() uses batch processing matching acceptAll() for consistent performance.
  </done>
</task>

</tasks>

<verification>
1. Open document, ask Claude to make 10+ changes
2. Click "Accept All" (or Ctrl+A) - should feel instant
3. Check console for timing log: "Batch apply completed in Xms" - should be < 100ms
4. Verify undo works (Ctrl+Z should revert all changes)
5. Test Reject All similarly - should be instant
6. Verify no visual glitches during batch operation
</verification>

<success_criteria>
- Accept All with 10+ changes completes in < 100ms (perceived as instant)
- Single DOM reflow during batch operation (verify in DevTools Performance tab)
- Undo correctly reverts batch accept/reject
- No regression in single-change accept/reject workflow
- Console logs batch timing for verification
</success_criteria>

<output>
After completion, create `.planning/phases/01-claude-changes-overhaul/01-03-SUMMARY.md`
</output>
