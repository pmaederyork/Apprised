---
phase: 01-claude-changes-overhaul
plan: 02
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - backend/static/js/claude-changes.js
  - backend/static/js/documents.js
autonomous: true

must_haves:
  truths:
    - "Change resolution tries ID-based targeting first, falls back to content matching"
    - "Failed change resolution skips with warning rather than blocking batch"
    - "Existing changes without targetId still work via content fallback"
  artifacts:
    - path: "backend/static/js/claude-changes.js"
      provides: "Hybrid change resolution"
      contains: "resolveChangeTarget"
    - path: "backend/static/js/documents.js"
      provides: "ID-first content lookup"
      contains: "data-edit-id"
  key_links:
    - from: "backend/static/js/claude-changes.js"
      to: "backend/static/js/element-ids.js"
      via: "ElementIds.findById() in resolveChangeTarget"
      pattern: "ElementIds\\.findById"
---

<objective>
Implement hybrid change resolution that prefers ID-based targeting with content fallback.

Purpose: Make change targeting reliable by using stable IDs when available, gracefully falling back to content matching for backward compatibility with existing change formats.

Output: Updated claude-changes.js with resolveChangeTarget() function and skip-on-failure behavior.
</objective>

<execution_context>
@/Users/pax/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pax/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-claude-changes-overhaul/01-CONTEXT.md
@.planning/phases/01-claude-changes-overhaul/01-RESEARCH.md
@.planning/phases/01-claude-changes-overhaul/01-01-SUMMARY.md
@backend/static/js/claude-changes.js
@backend/static/js/documents.js
@backend/static/js/element-ids.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add resolveChangeTarget() to ClaudeChanges</name>
  <files>backend/static/js/claude-changes.js</files>
  <action>
Add a new `resolveChangeTarget()` method to the ClaudeChanges object that implements the hybrid resolution strategy. Add this method after the `findNodeBySignature()` method (around line 120):

```javascript
/**
 * Resolve change target using hybrid strategy
 * Priority: targetId > cached signature > content matching
 * @param {Element} container - Container to search within
 * @param {Object} change - The change object with targetId, _cachedSignature, originalContent
 * @returns {Object} { node: Element|null, method: string }
 */
resolveChangeTarget(container, change) {
    // Strategy 1: ID-based (highest confidence)
    if (change.targetId) {
        const byId = typeof ElementIds !== 'undefined'
            ? ElementIds.findById(container, change.targetId)
            : container.querySelector(`[data-edit-id="${change.targetId}"]`);

        if (byId) {
            return { node: byId, method: 'id' };
        }
        console.warn(`Target ID "${change.targetId}" not found, trying fallback strategies`);
    }

    // Strategy 2: Cached signature (from preview phase)
    if (change._cachedSignature) {
        const bySignature = this.findNodeBySignature(container, change._cachedSignature);
        if (bySignature) {
            return { node: bySignature, method: 'signature' };
        }
    }

    // Strategy 3: Content matching (fallback for backward compatibility)
    if (change.originalContent) {
        const byContent = Documents.findNodeByContent(container, change.originalContent);
        if (byContent) {
            return { node: byContent, method: 'content' };
        }
    }

    // Strategy 4: For add changes, resolve anchor
    if (change.type === 'add') {
        const anchorContent = change.insertAfter || change.insertBefore;
        if (anchorContent) {
            // Try ID-based anchor resolution if anchor has targetId
            if (change.anchorTargetId) {
                const anchorById = typeof ElementIds !== 'undefined'
                    ? ElementIds.findById(container, change.anchorTargetId)
                    : container.querySelector(`[data-edit-id="${change.anchorTargetId}"]`);

                if (anchorById) {
                    return { node: anchorById, method: 'anchor-id' };
                }
            }

            // Fall back to content-based anchor resolution
            const anchorByContent = Documents.findNodeByContent(container, anchorContent);
            if (anchorByContent) {
                return { node: anchorByContent, method: 'anchor-content' };
            }
        }
    }

    // All strategies failed
    console.warn(`Could not locate target for change ${change.id}`, {
        hasTargetId: !!change.targetId,
        hasCachedSignature: !!change._cachedSignature,
        hasOriginalContent: !!change.originalContent,
        changeType: change.type
    });
    return { node: null, method: 'failed' };
},
```

This method:
- Tries ID-based targeting first (most reliable)
- Falls back to cached signature (from preview phase)
- Falls back to content matching (backward compatible)
- Handles add changes by resolving anchor elements
- Returns structured result with resolution method for debugging
  </action>
  <verify>
In claude-changes.js, the resolveChangeTarget method exists and includes all four strategies: ID, signature, content, and anchor resolution.
  </verify>
  <done>
resolveChangeTarget() method added with hybrid resolution strategy prioritizing ID-based targeting.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update reconstructDocument() to use hybrid resolution</name>
  <files>backend/static/js/claude-changes.js</files>
  <action>
Modify the `reconstructDocument()` method (around line 126) to use the new `resolveChangeTarget()` method instead of direct content matching. Also add skip-on-failure behavior.

Replace the existing reconstructDocument method body:

```javascript
/**
 * Reconstruct document from original HTML by applying accepted changes
 * This creates a clean document without wrapper divs
 * @param {string} originalHTML - The original clean document HTML
 * @param {Array} acceptedChanges - Changes to apply
 * @param {Object} options - { skipOnFailure: boolean }
 */
reconstructDocument(originalHTML, acceptedChanges, options = {}) {
    const { skipOnFailure = true } = options;

    console.log(`Reconstruction: Applying ${acceptedChanges.length} accepted change(s)`);

    // Create temporary container with original clean HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = originalHTML;

    // Track skipped changes for reporting
    const skipped = [];

    // Apply each accepted change in order
    acceptedChanges.forEach(change => {
        if (change.type === 'delete') {
            const result = this.resolveChangeTarget(tempDiv, change);

            if (result.node) {
                result.node.remove();
            } else if (skipOnFailure) {
                skipped.push({ change, reason: 'target not found' });
            } else {
                const preview = change.originalContent?.substring(0, 100) || 'unknown';
                console.error(`DELETE: Could not find content to delete: "${preview}..."`);
            }

        } else if (change.type === 'add') {
            const result = this.resolveChangeTarget(tempDiv, change);

            if (result.node) {
                const newElement = document.createElement('div');
                newElement.innerHTML = change.newContent;

                // Use DocumentFragment to preserve order
                const fragment = document.createDocumentFragment();
                while (newElement.firstChild) {
                    fragment.appendChild(newElement.firstChild);
                }

                if (change.insertAfter) {
                    result.node.after(fragment);
                } else if (change.insertBefore) {
                    result.node.before(fragment);
                }
            } else if (skipOnFailure) {
                skipped.push({ change, reason: 'anchor not found' });
                // Append to end as last resort
                tempDiv.innerHTML += change.newContent;
            } else {
                console.error('ANCHOR NOT FOUND for add operation');
                tempDiv.innerHTML += change.newContent;
            }

        } else if (change.type === 'modify') {
            const result = this.resolveChangeTarget(tempDiv, change);

            if (result.node) {
                const newElement = document.createElement('div');
                newElement.innerHTML = change.newContent;

                const fragment = document.createDocumentFragment();
                while (newElement.firstChild) {
                    fragment.appendChild(newElement.firstChild);
                }
                result.node.replaceWith(fragment);
            } else if (skipOnFailure) {
                skipped.push({ change, reason: 'target not found' });
            } else {
                const preview = change.originalContent?.substring(0, 100) || 'unknown';
                console.error(`MODIFY: Could not find content to modify: "${preview}..."`);
            }
        }
    });

    // Clear cache after reconstruction
    acceptedChanges.forEach(change => {
        delete change._cachedSignature;
    });

    // Report skipped changes
    if (skipped.length > 0) {
        console.warn(`Skipped ${skipped.length} change(s) during reconstruction:`, skipped);
    }

    return tempDiv.innerHTML;
},
```

Key changes:
- Uses resolveChangeTarget() for all change types
- Adds skipOnFailure option (default true) to prevent single failures from blocking batch
- Reports skipped changes for debugging
- Cleaner structure with consistent handling for each change type
  </action>
  <verify>
1. Check that reconstructDocument() method uses resolveChangeTarget() for delete, add, and modify operations
2. Check that skipOnFailure logic exists with default value of true
3. Check that skipped array is populated and logged
  </verify>
  <done>
reconstructDocument() updated to use hybrid resolution with skip-on-failure behavior for robust batch operations.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update renderChangesInDocument() to capture targetId</name>
  <files>backend/static/js/documents.js</files>
  <action>
Modify `renderChangesInDocument()` in documents.js (around line 1881) to capture the targetId from elements when caching signatures. This ensures changes have targetId for future resolution.

In the existing renderChangesInDocument method, update each change type handling to capture targetId:

**For DELETE changes (around line 1907-1930):**
```javascript
if (change.type === 'delete') {
    // ... existing wrapper code ...

    const originalNode = this.findNodeByContent(tempDiv, change.originalContent);
    if (originalNode) {
        // Capture targetId if element has one
        if (originalNode.dataset.editId) {
            change.targetId = originalNode.dataset.editId;
        }

        // Existing signature caching code...
        change._cachedSignature = {
            textContent: originalNode.textContent?.trim() || '',
            tagName: originalNode.tagName?.toLowerCase() || '',
            innerHTML: originalNode.innerHTML || '',
            outerHTML: originalNode.outerHTML || ''
        };
        originalNode.replaceWith(changeElement);
    }
    // ... rest of existing code ...
}
```

**For ADD changes (around line 1931-1975):**
```javascript
if (change.type === 'add') {
    // ... existing wrapper code ...

    if (change.insertAfter) {
        const anchorNode = this.findNodeByContent(tempDiv, change.insertAfter);
        if (anchorNode) {
            // Capture anchor targetId if element has one
            if (anchorNode.dataset.editId) {
                change.anchorTargetId = anchorNode.dataset.editId;
            }

            // Existing signature caching code...
            change._cachedSignature = {
                textContent: anchorNode.textContent?.trim() || '',
                tagName: anchorNode.tagName?.toLowerCase() || '',
                innerHTML: anchorNode.innerHTML || '',
                outerHTML: anchorNode.outerHTML || '',
                anchorType: 'insertAfter'
            };
            anchorNode.after(changeElement);
        }
        // ... rest of existing code ...
    } else if (change.insertBefore) {
        const anchorNode = this.findNodeByContent(tempDiv, change.insertBefore);
        if (anchorNode) {
            // Capture anchor targetId if element has one
            if (anchorNode.dataset.editId) {
                change.anchorTargetId = anchorNode.dataset.editId;
            }

            // Existing signature caching code...
            change._cachedSignature = { /* existing code */ };
            anchorNode.before(changeElement);
        }
        // ... rest of existing code ...
    }
}
```

**For MODIFY changes (around line 1976-1998):**
```javascript
if (change.type === 'modify') {
    // ... existing wrapper code ...

    const originalNode = this.findNodeByContent(tempDiv, change.originalContent);
    if (originalNode) {
        // Capture targetId if element has one
        if (originalNode.dataset.editId) {
            change.targetId = originalNode.dataset.editId;
        }

        // Existing signature caching code...
        change._cachedSignature = { /* existing code */ };
        originalNode.replaceWith(changeElement);
    }
    // ... rest of existing code ...
}
```

This ensures that when changes are previewed, we capture the element's stable ID for later reconstruction, making subsequent accept/reject operations more reliable.
  </action>
  <verify>
1. Search for `change.targetId =` in documents.js - should appear in delete and modify handlers
2. Search for `change.anchorTargetId =` in documents.js - should appear in add handlers
3. Both should check `dataset.editId` before assignment
  </verify>
  <done>
renderChangesInDocument() captures targetId and anchorTargetId from elements with stable IDs during preview phase.
  </done>
</task>

</tasks>

<verification>
1. Load app, open document, ask Claude to make a change
2. Accept the change - should work via ID-based targeting
3. Check console for resolution method logs (should show 'id' or 'signature')
4. Test with an old document that has no IDs - should fall back to content matching
5. Manually corrupt a targetId and verify change is skipped with warning, not blocking error
</verification>

<success_criteria>
- resolveChangeTarget() method exists with 4-strategy hybrid resolution
- reconstructDocument() uses hybrid resolution for all change types
- Failed resolutions skip with warning rather than throwing errors
- renderChangesInDocument() captures targetId/anchorTargetId from elements
- Existing content-only changes still work via fallback
</success_criteria>

<output>
After completion, create `.planning/phases/01-claude-changes-overhaul/01-02-SUMMARY.md`
</output>
